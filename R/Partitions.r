#' Generates all set-partition matrices for N elements
#'
#' @param N The (integer) number of elements to be partitioned
#' @return U a matrix containing all the partion matrices
#' @return S_N_r the number of partitions of size r including r=1 blocks,
#' r=2 blocks etc.
#' @examples
#' Partition_Generator(3)
#' @references G.H.Terdik, Multivariate statistical methods - going beyond the linear,
#' Springer 2021.  Section 1.4.1
#'
#' @family Partitions
#' @export
Partition_Generator<-function(N){
U1<-matrix(c(1,1,1,0,0,1),3,2,byrow=T)
#U1
if (N==1) {return(list("U"=1,"S_N_r"=1))}
if (N==2) {return(list("U"=U1, "S_N_r"=c(1,1)))}
S_N_r=c(1,1)
szam2=NULL
U2=NULL
szam2[1]=1
sep=cumsum(S_N_r*(1:2))

for (n in 3:N) {
  U2=NULL
  U2<-rbind(rep(1,n))
  U2<-rbind(U2,c(U1[1,],0))
  U2<-rbind(U2,c(rep(0,n-1),1))
  #U2
  for (m in 2:(n-1)){
  szam2[m]= S_N_r[m-1]+m*S_N_r[m]
  bent<-rep(0,m) #use as column vector
    for (k in 1:S_N_r[m]){
      sor=sep[m-1]+(k-1)*m+1
      # inclusive partitions
        for (b in 1:m){
          meret<-dim(U2)
          bent[b]<-1
          U2<-rbind(U2,cbind(U1[sor:(sor+m-1),],bent))
          bent[b]<-0
        }
    }
  #Exclusive partitions
  for (k in 1:S_N_r[m]){
    sor<-sep[m-1]+(k-1)*m+1
    meret<-dim(U2)
    U2<-rbind(U2,cbind(U1[sor:(sor+m-1),],bent))
    U2<-rbind(U2,c(rep(0,n-1),1))
  }
  }
 S_N_r=c(szam2,1)
 sep=cumsum(S_N_r*(1:n))
 U1<-U2
 colnames(U1)<-NULL
 U2<-NULL
}
return(list("U"=U1,"S_N_r"=S_N_r))
}


#' Generates all disjoint set-partition matrices for N elements
#'
#' @inheritParams Partition_Generator
#' @return U the list of partition matrices  of size r.
#' @return S_N_r the number of partitions of size r including r=1 blocks,
#' r=2 blocks etc.
#'
#' @examples
#' PA<-Partition_All(4)
#' PA$U
#' PA$S_N_r
#' @references G.H.Terdik, Multivariate statistical methods - going beyond the linear,
#' Springer 2021.  Section 1.4.1 (see Table 1.3, p.23, with partitions for n=4)
#'
#' @family Partitions
#' @export
Partition_All <- function(N){

PG<-Partition_Generator(N)
  U1<-PG$U
  S_N_r<-PG$S_N_r
  sep<-cumsum(S_N_r*(1:N))
  U<-list()
  U[[1]]<-rep(1,N) ### first output
  if (N==1) {return(list("U"=U, "S_N_r"=1))}
M=1
for (m in 2:N) {
  U2<-U1[(sep[m-1]+1):sep[m],]
  for (k in 1:S_N_r[m]){
    M<- M+1
    sor<-(k-1)*m+1
    K<-U2[sor:(sor+m-1),]
    I<-order(apply(K,1,sum),decreasing=T)
    U[[M]]<-K[I,] # output
  }
}
return(list("U"=U,"S_N_r"=S_N_r))
}

#' Partition into pairs of the set 1:N
#'
#' @inheritParams Partition_Generator
#' @return K2 The list of partition matrices, the list
#' is empty if \code{N} is odd.
#'
#' @references G.H.Terdik, Multivariate statistical methods - going beyond the linear,
#' Springer 2021.  Section 1.4.8
#'
#' @family Partitions
#' @export
Partition_Pairs<- function(N){
if (N<=2) {K2=list()
return(K2)}
  if (N %% 2==0){
  m=N/2
  PA<-Partition_All(N)
  U<-PA[[1]]
  szaml<-PA[[2]]
  osz<-cumsum(szaml)
  K2<-list()
  M<-0
  for (k in 1:szaml[m]){
    K<-U[[osz[m-1]+k]]
    if (all(apply(K,1,sum)==2*rep(1,m))){
      M=M+1
      K2[[M]]<-K
    }
  }
}
  else {K2<-list()}
return("K2"=K2)
  }


#' Permute elements according to partition pU
#'
#' @param pU A partition matrix generated by Partition_All
#' @return perm_pU The elements \code{1} to \code{N} permuted according to \code{pU}
#'
#' @examples
#' PA<-Partition_All(4)
#' Partition_2Perm(PA$U[[3]])
#'
#' @references G.H.Terdik, Multivariate statistical methods - going beyond the linear,
#' Springer 2021.  Section 1.4.4
#'
#' @family Partitions
#' @export
Partition_2Perm<-function(pU){
n<-max(dim(pU))
h<-min(dim(pU))
ordBlock<-order(apply(pU,1,sum),decreasing=T)
pU1=pU[ordBlock,]
nElem<-1:n
perm_pU<-NULL
for (k in 1:h) {perm_pU=c(perm_pU,nElem[(pU1[k,]==1)])}
return("Perm_pU"=perm_pU)
}

#' Checking indecomposability
#'
#' Produce the list of all indecomposable partitions
#' with respect to the partition matrix L
#'
#' @param L A partition matrix
#' @return IndecompK2L the list of partition matrices
#' indecomposable with respect to \code{L}
#' @return numb_by_sizes nuber of indecomposable partitions
#' with respect to \code{L} by sizes
#'
#' @examples
#' L<-matrix(c(1,1,0,0,0,0,1,1),2,4,byrow=T)
#' IP<-Partition_Indecomposable(L)
#' IP$IndecompK2L
#' IP$num_by_sizes
#'
#' @references G.H.Terdik, Multivariate statistical methods - going beyond the linear,
#' Springer 2021.  Section 1.4.6
#'
#' @family Partitions
#' @export
Partition_Indecomposable<-function(L){

N<-max(dim(L))
PA<- Partition_All(N)
U1<-PA[[1]]
szaml<-PA[[2]]
IndecompK2L=list()

IndecompK2L[[1]]<-U1[[1]]
M1<-NULL
M2<-1
osz<-cumsum(szaml)
for (m in 2:N) {
  M<-1
  for (k in 1:szaml[m]){
    sor<-osz[m-1]
    K<-U1[[sor+k]]
    L1<- L%*%t(K)
    L2<-t(L1)%*%L1
    sL<-dim(L2)
    a1<-1
    a<-which(L2[1,]!=0)
    la<-length(a)
    la1<-length(a1)
    while (la1!=la){
      a1=a
      for (p in 2:length(a)){
        b<-which(L2[a[p],]!=0)
        a<-union(a,b)
      }
      la1=length(a1)
      la=length(a)
    }
    if (la==sL[1]){
      M=M+1
      M2=M2+1
      IndecompK2L[[M2]]=K
    }
  }
  M1[m]=M-1
}

numb_by_sizes<-c(1,M1[2:N])
return(list("IndecompK2L"=IndecompK2L,"num_by_sizes"=numb_by_sizes))
}

#' Type and number of partitions
#'
#' Generates all partitions of \code{N} numbers and classify by type
#'
#' @inheritParams Partition_Generator
#' @return Part.class A list of all possible partitions
#' @return S_N_r A vector with the number of partitions of size r=1, r=2, etc.
#' @return eL_r A list with partition types
#' @return S_r_j
#'
#' @examples
#' PTA<-Partition_Type_All(5)
#' # Partitions generated
#' PTA$Part.class
#' # Partitions of size 3
#' PTA$eL_r[[3]]
#' # Number of partitions with r=1 blocks, r=2 blocks, etc-
#' PTA$S_N_r
#' # ????
#' PTA$S_r_j
#'
#' @references G.H.Terdik, Multivariate statistical methods - going beyond the linear,
#' Springer 2021.  Definition 1.4
#'
#' @family Partitions
#' @export
Partition_Type_All<-function(N){
## da verificare
PA<-Partition_All(N)
U<-PA$U
S_N_r<-PA$S_N_r
sepL<-cumsum(S_N_r)

eL_r<-list()
S_r_j<-list()
part_K<-list()
part_class<-list()

eL_r[[1]]<-c(rep(0,N-1),1)
S_r_j[[1]]<- 1
part_class[[1]]<-U[[1]]

if (N==1) return(list("Part.class"=U,"S_N_r"=S_N_r,"eL_r"=eL_r,"S_r_j"=S_r_j))
if (N==2) {
  eL_r[[N]]<-c(N,rep(0,N-1))
  S_r_j[[N]]<-1
  return(list("Part.class"=U,"S_N_r"=S_N_r,"eL_r"=eL_r,"S_r_j"=S_r_j))
}
for (r in 2:(N-1)){
  type_1<-matrix(0,S_N_r[r],N)

  for (k in 1:S_N_r[r]){
    type0<-matrix(0,1,N)
    K=U[[sepL[r-1]+k]]
    sK=apply(K,1,sum)
    C<-unique(sK)
    ia<-match(unique(sK), sK)

    if (length(ia)==1) {ind_type<-r}
    else ind_type<- diff(c(ia,r+1))

  type0[C]<- ind_type
  type_1[k,]<-type0
  part_K[[k]]<- K
  }
  y = lapply(seq_len(ncol(type_1)), function(i) type_1[,i])
  ind_type = do.call("order", c(y,list(decreasing=T)))
  type_2<-type_1[ind_type,]
  iat<-(1:nrow(type_2))[!duplicated(type_2)]
  eL_r[[r]]<-type_2[iat,]

if (length(iat)==1) { S_r_j[[r]]<-S_N_r[[r]] }

else S_r_j[[r]]<-diff(c(iat,S_N_r[r]+1))

part_class<-c(part_class,part_K[ind_type])
}
eL_r[[N]]<-c(N,rep(0,N-1))
S_r_j[[N]]<-1
part_class<-c(part_class,tail(U,n=1))

return(list("Part.class"=part_class,"S_N_r"=S_N_r,"eL_r"=eL_r,"S_r_j"=S_r_j))
}


#' Find the  parameters  of a given type (eL) of partition
#'
#' @param eL A partition of a given type
#' @return r The partition's size
#' @return mm The row number in the matrix of types of
#' that partition
#'
#'
#' @examples
#' eL<-c(3,1,1,0,0,0,0,0)
#' Partition_Type_eL_Location(eL)
#' # eL is in the 5th cell 2nd row
#'
#' @references G.H.Terdik, Multivariate statistical methods - going beyond the linear,
#' Springer 2021.  Section 1.4
#'
#' @family Partitions
#' @export
Partition_Type_eL_Location<- function(eL){
N=length(eL)
eL_j<-Partition_Type_All(N)$eL_r
loc_type_el=c(0,0)
for (r in 1:N){
  if  (is.vector(eL_j[[r]])){
    if (prod((eL==eL_j[[r]]))){
      loc_type_el<- c(r,1)
    }
  }
    else {
  eL_jt<-eL_j[[r]]
  for (mm in 1:dim(eL_jt)[[1]]){
    if (prod((eL==eL_jt[mm,]))){
        loc_type_el<- c(r,mm)
        }
      }
    }
  }
return(loc_type_el)
}
